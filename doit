#!/usr/bin/env python3
"""Wrapper that ensures `.venv` has doit installed then forwards all args to it.

This wrapper is intentionally small: it will create `.venv` if missing,
install `doit` into it (using pip), and exec the venv's `doit` binary (or
fall back to `python -m doit`) forwarding all command-line arguments.

Usage: ./doit [args...]
Example: ./doit list
"""

import os
import shutil
import subprocess
import sys


VENV_DIR = ".venv"


def venv_python(venv: str = VENV_DIR) -> str:
    return os.path.join(venv, "bin", "python")


def venv_do_it(venv: str = VENV_DIR) -> str:
    return os.path.join(venv, "bin", "doit")


def create_venv(venv: str = VENV_DIR) -> None:
    if os.path.isdir(venv):
        return
    print("Creating virtual environment in .venv...")
    py = sys.executable or "python3"
    subprocess.check_call([py, "-m", "venv", venv])


def ensure_pip(py: str) -> None:
    try:
        subprocess.check_call([py, "-m", "pip", "--version"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except subprocess.CalledProcessError:
        subprocess.check_call([py, "-m", "ensurepip", "--upgrade"])


def ensure_doit(py: str) -> None:
    try:
        subprocess.check_call([py, "-c", "import doit"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except subprocess.CalledProcessError:
        print("Installing doit into .venv...")
        subprocess.check_call([py, "-m", "pip", "install", "--upgrade", "pip"]) 
        subprocess.check_call([py, "-m", "pip", "install", "doit"]) 


def main(argv: list) -> None:
    # ensure venv exists
    create_venv(VENV_DIR)
    py = venv_python(VENV_DIR)
    if not os.path.exists(py):
        print("ERROR: python executable not found in .venv", file=sys.stderr)
        sys.exit(2)
    ensure_pip(py)
    ensure_doit(py)

    doit_bin = venv_do_it(VENV_DIR)
    args = argv[1:]
    # Prefer running the doit binary if available, otherwise run as module
    if os.path.exists(doit_bin) and os.access(doit_bin, os.X_OK):
        os.execv(doit_bin, [doit_bin] + args)
    else:
        os.execv(py, [py, "-m", "doit"] + args)


if __name__ == "__main__":
    try:
        main(sys.argv)
    except subprocess.CalledProcessError as e:
        print(f"Command failed with exit code {e.returncode}", file=sys.stderr)
        sys.exit(e.returncode)
    except KeyboardInterrupt:
        print("Interrupted", file=sys.stderr)
        sys.exit(130)
